// #include "linux_configs.h"
// #include <linux/mmzone.h>
// #include <linux/mm_types.h>
// #include <linux/list.h>
#include <stdio.h>

#include "linux-configs-3.2.0-29-virtual.h" // for CONFIG_* checked below for define's
#include "linux-headers-3.2.0-29-virtual.h" // all-in-one header file generated by compiling empty module with EXTRA_CFLAG = -E

void *mem;

/*
 * Below, necessary define's are copied from corresponding header files.
 */

#define NULL 0

#define __deref(ptr) \
	((typeof(*ptr) *) (mem + (((unsigned long) ptr) - 0xc0000000)))

/* ********************************
 * linux/mmzone.h
 * ******************************** */

/* Free memory management - zoned buddy allocator.  */
#ifndef CONFIG_FORCE_MAX_ZONEORDER
#define MAX_ORDER 11
#else
#define MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER
#endif
#define MAX_ORDER_NR_PAGES (1 << (MAX_ORDER - 1))

#define MIGRATE_UNMOVABLE     0
#define MIGRATE_RECLAIMABLE   1
#define MIGRATE_MOVABLE       2
#define MIGRATE_PCPTYPES      3 /* the number of types on the pcp lists */
#define MIGRATE_RESERVE       3
#define MIGRATE_ISOLATE       4 /* can't allocate from here */
#define MIGRATE_TYPES         5

#ifdef CONFIG_NUMA
#define zone_pcp(__z, __cpu) ((__z)->pageset[(__cpu)])
#else
#define zone_pcp(__z, __cpu) (&(__z)->pageset[(__cpu)])
#endif

/* ********************************
 * linux/compiler-gcc4.h
 * ******************************** */

#define __compiler_offsetof(a,b) __builtin_offsetof(a,b)

// linux/stddef.h
#undef offsetof
#ifdef __compiler_offsetof
#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
#endif

/* ********************************
 * linux/kernel.h
 * ******************************** */

/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 */
#define container_of(ptr, type, member) ({			\
	const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
	(type *)( (char *)__mptr - offsetof(type,member) );})

/* ********************************
 * linux/list.h
 * ******************************** */

// Dummy entry to nullify prefetch function, which doesn't matter for compilation.
#define prefetch(x) (x)

/**
 * list_entry - get the struct for this entry
 * @ptr:	the &struct list_head pointer.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_struct within the struct.
 */
#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)

/**
 * list_for_each_entry	-	iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_struct within the struct.
 */
/*
#define list_for_each_entry(pos, head, member)				\
	for (pos = list_entry((head)->next, typeof(*pos), member);	\
	     prefetch(pos->member.next), &pos->member != (head); 	\
	     pos = list_entry(pos->member.next, typeof(*pos), member))
*/
#define list_for_each_entry(pos, head, member)				\
	for (pos = list_entry(__deref((head)->next), typeof(*pos), member); \
	     &pos->member != (head);					\
	     pos = list_entry(__deref(pos->member.next), typeof(*pos), member))

// Copied from generated/bounds.h
#define MAX_NR_ZONES 4 /* __MAX_NR_ZONES	# */

// Copied and modified from mmzone.c
struct zone *next_zone(struct zone *zone)
{
	pg_data_t *pgdat = __deref(zone->zone_pgdat);

	if (zone < pgdat->node_zones + MAX_NR_ZONES - 1)
		zone++;
	else
		zone = NULL;

	return zone;
}

int scan(void *_mem, unsigned long pglist_pos, unsigned long page_zero_pos,
	 unsigned char *bitmap, unsigned long len)
{
	struct pglist_data *pgdat;
	// struct zoneref *z;
	struct zone *zone;
	// struct zonelist *zonelist;
	// int high_zoneidx;
	unsigned int order;
	struct page *page_zero;

	struct free_area *area;
	struct page *page;
	int migratetype;
	int idx;
	unsigned long pfn;
	struct per_cpu_pages *pcp;
	struct list_head *list;
	int ret = 0;

	unsigned int cpu = 0; // Assume a single core

	mem = _mem;

	for (idx = 0; idx < len; idx++)
		bitmap[idx] = 0;

	pgdat = __deref((struct pglist_data *) pglist_pos);
	page_zero = __deref((struct page *) page_zero_pos); 
	if (pgdat->nr_zones == 0){
		//fprintf(stderr, "nr_zone is invalid : %d\n", pgdat->nr_zones);
		return -2;
	}

	/*
	for (idx = 0; idx < len; idx++)
		if (! page_zero[idx]._count.counter)
			bitmap[idx] = 1;
	*/

	for (zone = pgdat->node_zones; zone; zone = next_zone(zone)) {
		// see if order == 0 case should be handled separately
		for (migratetype = 0; migratetype < MIGRATE_TYPES; migratetype++) {
			if (migratetype < MIGRATE_PCPTYPES) {
				// Process per-cpu free list for order == 0
				pcp = &(&zone->pageset[0])->pcp;  // should be the same effect as this_cpu_ptr()

				if ((pcp != NULL) && (pcp->count != NULL)){
					if (pcp->count > 0) {
						list = &pcp->lists[migratetype];
						if (list->next) {
							list_for_each_entry(page, list, lru) {
								pfn = (unsigned long) (page - page_zero);
								if (pfn < len)
									bitmap[pfn] = 1;
								else
									ret = -1;
							}
						}
					}
				}
			}

			// Process free lists for order 1 and beyond
			for (order = 0; order < MAX_ORDER; order++) {
				area = &(zone->free_area[order]);

				if (!area->nr_free)
					continue;

				if (list_empty(&area->free_list[migratetype]))
					continue;

				list_for_each_entry(page, &area->free_list[migratetype], lru) {
					for (idx = 0; idx < (1 << order); idx++) {
						pfn = (unsigned long) (page - page_zero) + idx;

						if (pfn < len)
							bitmap[pfn] = 1;
						else
							ret = -1;
					}
				}
			}
		}
	}

	return ret;
}
